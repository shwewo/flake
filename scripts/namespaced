#!/usr/bin/env bash
PROGNAME="$(basename "$0")"

usage() {
  cat << EOF
Usage: sudo $PROGNAME [options]

This script creates network namespace that always utilizes your ISP
It's useful, for example, to connect to a VPN through your ISP, not through VPN you are connected

To execute programs inside of network namespace, use: 
- sudo ip netns exec sudo -u <user> <program>
- firejail --netns=nsd --noprofile <program>

Options:
  -h --help                    Show help
  -n --name <name>             Veth pair and network namespace name (default: nsd)
  -c --country <CODE>          Country code to compare if somehow you are still connected through VPN (e.g. VPN tethering)
  -d --dns <ip>                DNS servers in the namespace, use "," separator (default 1.1.1.1, 1.0.0.1)
  --veth0-ip <ip>              Veth0 ip address (default: 198.18.10.1)
  --veth1-ip <ip>              Veth0 ip address (default: 198.18.10.2)
  --fwmark <fwmark>            Fwmark of the routed packets (default: 105)
  --table <table>              Routing table of the namespace (default: 105)
  --nokill                     Don't kill programs inside of namespace
EOF
}

define_variables() {
  RUNNING=true
  RUNNING_PID=$$
  
  NAME="nsd"
  COUNTRY_CHECK=
  VETH0_NAME=
  VETH1_NAME=
  VETH0_IP="198.18.10.1"
  VETH1_IP="198.18.10.2"
  DNS="1.1.1.1, 1.0.0.1"
  FWMARK=105
  TABLE=105
  NOKILL=false
  
  NAMESPACE_GW=
  DEFAULT_GW=
  DEFAULT_IFACE=
  NAMESERVER_1=
  NAMESERVER_2=
  OLD_IPV4_FORWARD=$(sysctl -n net.ipv4.ip_forward)
  OLD_MASQUARADE=
}

parse_options() {
  while [[ -n "$1" ]]; do
    case "$1" in
      -h|--help) usage; exit 0 ;;
      -n|--name) shift; NAME=$1; shift ;;
      -c|--country) shift; COUNTRY_CHECK=$1; shift ;;
      -d|--dns) shift; DNS=$1; shift ;;
      --veth0-ip) shift; VETH0_IP=$1; shift ;;
      --veth1-ip) shift; VETH1_IP=$1; shift ;;
      --fwmark) shift; FWMARK=$1; shift ;;
      --table) shift; TABLE=$1; shift ;;
      --nokill) shift; NOKILL=true;;
      *) echo  "Invalid parameter: $1" 1>&2; exit 1 ;;
    esac
  done

  if [ "$(id -u)" -ne 0 ]; then
    echo "This script must be run as root."
    exit 1
  fi
  
  if ip netns | grep -q "$NAME"; then
    echo "This script is already running!"
    exit 1
  fi

  VETH0_NAME=$NAME"0"
  VETH1_NAME=$NAME"1"
  IFS=", " read -r NAMESERVER_1 NAMESERVER_2 <<< "$DNS"
}

########################################################################################################################

get_gateway() {
  while true; do
    DEFAULT_IFACE=$(ip route show default | awk '{print $5; exit}')
    DEFAULT_GW=$(ip route show default | awk '{print $9; exit}')
    NAMESPACE_GW=$(ip route show default | awk '{print $3; exit}')
    if [[ -n "$DEFAULT_IFACE" || -n "$NAMESPACE_GW" || -n "$DEFAULT_GW" ]]; then
      break
    else
      sleep 3
    fi
  done

  echo "Namespace gateway: $NAMESPACE_GW"
  echo "Default gateway: $DEFAULT_GW"
  echo "Default interface: $DEFAULT_IFACE"
  OLD_MASQUARADE=$(iptables-save | grep -q -- "-A POSTROUTING -o $DEFAULT_IFACE -j MASQUERADE" && echo true || echo false)
}

do_rules() {
  ip rule $1 fwmark $FWMARK table $TABLE 2>/dev/null
  ip rule $1 from $VETH1_IP table $TABLE 2>/dev/null
  ip rule $1 to $VETH1_IP table $TABLE 2>/dev/null
  ip route $1 default via $NAMESPACE_GW dev $DEFAULT_IFACE table $TABLE 2>/dev/null
  ip route $1 $VETH1_IP via $VETH0_IP dev $VETH0_NAME table $TABLE 2>/dev/null
}

do_iptables() {
  iptables -t nat $1 POSTROUTING -o "$DEFAULT_IFACE" -j MASQUERADE 2>/dev/null
}

do_net_access() {
  iptables $1 INPUT -i $VETH0_NAME -p icmp -d $NAMESERVER_1 -j ACCEPT 2>/dev/null
  iptables $1 FORWARD -i $VETH0_NAME -p icmp -d $NAMESERVER_1 -j ACCEPT 2>/dev/null
  iptables $1 OUTPUT -o $VETH0_NAME -p icmp -d $NAMESERVER_1 -j ACCEPT 2>/dev/null

  iptables $1 INPUT -i $VETH0_NAME -p tcp --dport 443 -d cloudflare.com -j ACCEPT 2>/dev/null
  iptables $1 FORWARD -i $VETH0_NAME -p tcp --dport 443 -d cloudflare.com -j ACCEPT 2>/dev/null
  iptables $1 OUTPUT -o $VETH0_NAME -p tcp --sport 443 -d cloudflare.com -j ACCEPT 2>/dev/null
  
  iptables $1 INPUT -i $VETH0_NAME -j DROP 2>/dev/null
  iptables $1 FORWARD -i $VETH0_NAME -j DROP 2>/dev/null
  iptables $1 OUTPUT -o $VETH0_NAME -j DROP 2>/dev/null
}

########################################################################################################################

country_check() {
  if [[ -n "$COUNTRY_CHECK" ]]; then
    echo "Checking country..."
    do_net_access "-A"

    while true; do
      local response=$(ip netns exec $NAME curl -m 10 -s https://cloudflare.com/cdn-cgi/trace)

      if [ $? -eq 0 ] && [ -n "$response" ]; then
        local country=$(echo -e "$response" | awk -F= '/^loc/{print $2; exit 0}')
        local ip=$(echo -e "$response" | awk -F= '/^ip/{print $2; exit 0}')

        if [[ $country != "$COUNTRY_CHECK" ]]; then
          echo -e "IP: $ip\nCountry: $country\nNetwork access is disabled!"
          break
        else
          echo -e "IP: $ip\nCountry: $country"
          do_net_access "-D"
          break
        fi
      else
        echo "Curl request failed, retrying..."        
        sleep 1
      fi
    done
  fi
}

conn_check() {
  local connected=true;
  sleep 3
  while true; do
    if ip netns exec $NAME ping -c 1 -W 3 $NAMESERVER_1 &> /dev/null; then
      if [ "$connected" = false ]; then
        echo "Connection restored"
      fi
      connected=true
    else
      connected=false
      echo "No ping from $NAMESERVER_1, are we connected to the internet?"
    fi
    sleep 15
  done
}

monitor() {
  ip monitor route dev $DEFAULT_IFACE | while read event; do
    case "$event" in
      *"$DEFAULT_GW"*)
        do_rules "del"
        [ "$OLD_MASQUARADE" = false ] && do_iptables "-D"
        break
      ;;
    esac
  done
}

cleanup() {
  if [ "$RUNNING" = true ]; then
    RUNNING=false
    if [ "$NOKILL" = true ]; then
      kill -SIGINT -$RUNNING_PID &>/dev/null
    else
      local pids=$(find -L /proc/[1-9]*/task/*/ns/net -samefile /run/netns/$NAME | cut -d/ -f5)
      kill -SIGINT -$pids &> /dev/null
      kill -SIGTERM -$pids &> /dev/null
      kill -SIGINT -$RUNNING_PID &>/dev/null
    fi

    do_rules "del"
    [ "$OLD_MASQUARADE" = false ] && do_iptables "-D"
    do_net_access "-D"
    sysctl -wq net.ipv4.ip_forward=$OLD_IPV4_FORWARD 2>/dev/null

    ip link del $VETH0_NAME 2>/dev/null
    ip netns del $NAME 2>/dev/null
    rm -rf /etc/netns/$NAME/ &> /dev/null
    rm -rf /var/run/netns/$NAME/ &> /dev/null

    echo "Exiting..."
    exit 0
  fi
}

init() {
  define_variables
  parse_options "$@"
  trap cleanup INT TERM

  ip netns add $NAME
  ip link add $VETH0_NAME type veth peer name $VETH1_NAME
  ip link set $VETH1_NAME netns $NAME
  ip addr add $VETH0_IP/24 dev $VETH0_NAME
  ip link set $VETH0_NAME up
  ip netns exec $NAME ip link set lo up
  ip netns exec $NAME ip addr add $VETH1_IP/24 dev $VETH1_NAME
  ip netns exec $NAME ip link set $VETH1_NAME up
  ip netns exec $NAME ip route add default via $VETH0_IP
  mkdir -p /etc/netns/$NAME
  echo -e "nameserver $NAMESERVER_1\nnameserver $NAMESERVER_2" > /etc/netns/$NAME/resolv.conf
  sysctl -wq net.ipv4.ip_forward=1
  conn_check &
  
  while true; do
    get_gateway
    do_rules "add"
    [ "$OLD_MASQUARADE" = false ] && do_iptables "-A" 2
    country_check
    monitor & wait
  done
}

init "$@"